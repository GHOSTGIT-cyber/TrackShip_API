<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üõ∞Ô∏è Surveillance des navires - Seine</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="assets/style.css" />
    
</head>
<body>
    <!-- Badge Hostinger -->
    <div class="hostinger-badge">üöÄ Powered by Ghost</div>
    
    <!-- Banni√®re d'alerte (ajout√©e dynamiquement) -->
    
    <!-- Compteur de rafra√Æchissement -->
    <div id="compteurRefresh" class="compteur-refresh" style="display: none;">
        <div>Actualisation dans <span id="tempsRestant">10</span>s</div>
        <div id="modeActualisation" style="font-size: 12px; opacity: 0.8;">Mode: Normal</div>
    </div>

    <div class="container">
        <div class="header">
            <h1>üõ∞Ô∏è Surveillance des navires en mouvement Foil in Paris</h1>
            <p> ‚Ä¢ surveillance automatique avec alertes de proximit√© ‚Ä¢ Suivi temps r√©el zone rouge ‚Ä¢ </p>
        </div>

        <div class="controls">
            <div class="form-group">
                <div>
                    <label for="token">üîë Token d'acc√®s</label>
                    <input type="text" id="token" placeholder="Votre token d'acc√®s">
                </div>
                <div>
                    <label for="rayon">üìè Rayon (km)</label>
                    <input type="number" id="rayon" value="3" min="1" max="50">
                </div>
                <div>
                    <label for="filtreNavires">üö¢ Type de navires</label>
                    <select id="filtreNavires">
                        <option value="tous">Tous les navires</option>
                        <option value="mouvement">En mouvement uniquement</option>
                        <option value="arret">√Ä l'arr√™t uniquement</option>
                    </select>
                </div>
                <div>
                    <button class="btn" id="btnSurveillance" onclick="demarrerSurveillance()">üîç D√©marrer la surveillance</button>
                </div>
            </div>
            
            <!-- Indicateur de statut -->
            <div id="statusIndicator" class="status-indicator" style="display: none;">
                <span id="statusText">Pr√™t</span>
            </div>
        </div>

        <div class="content">
            <div class="map-container">
                <div id="map"></div>
            </div>
            
            <div class="sidebar">
                <div class="stats">
                    <h3>üìä Statistiques</h3>
                    <div class="stat-item">
                        <span class="stat-label">Navires d√©tect√©s</span>
                        <span class="stat-value" id="totalNavires">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">üü¢ Zone d'approche (3km)</span>
                        <span class="stat-value" id="naviresApproche">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">üü† Zone vigilance (2km)</span>
                        <span class="stat-value" id="naviresVigilance">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">üî¥ Zone alerte (1km)</span>
                        <span class="stat-value" id="naviresAlerte">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">üéØ Track√©s en temps r√©el</span>
                        <span class="stat-value" id="naviresTrackes">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">üìã Navires num√©rot√©s</span>
                        <span class="stat-value" id="naviresNumerotes">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">Derni√®re MAJ</span>
                        <span class="stat-value" id="derniereMaj">Jamais</span>
                    </div>
                </div>

                <!-- Compteur journalier de passages -->
                <div id="panneauCompteurJournalier" class="compteur-journalier">
                    <h3>üìä Compteur de passages - Zone Rouge</h3>
                    <div class="compteur-jour-actuel">
                        <div class="jour-label">Jour 1 (Aujourd'hui)</div>
                        <div class="jour-compteur">0 passage</div>
                    </div>
                    <div class="compteur-historique"></div>
                </div>

                <!-- Panneau d'attention int√©gr√© dans la sidebar -->
                <div id="panneauAttentionSidebar" class="panneau-attention-sidebar" style="display: none;">
                    <div class="panneau-titre">
                        <span>üü†</span>
                        <strong>NAVIRES EN MOUVEMENT - ZONE 2KM</strong>
                    </div>
                    <div id="contenuPanneauAttention"></div>
                </div>

                <div class="navires-list">
                    <h3>üö¢ Navires surveill√©s</h3>
                    <div id="listeNavires" class="loading">
                        Cliquez sur "D√©marrer la surveillance" pour commencer...
                    </div>
                </div>

                <!-- Nouvelle section pour les navires non conformes -->
                <div class="navires-list" id="sectionNonConformes" style="display: none;">
                    <h3>‚ö†Ô∏è Navires non conformes</h3>
                    <div id="listeNonConformes" class="loading">
                        Aucun navire non conforme d√©tect√©
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Configuration de la base de surveillance - VERROUILL√âE C√îT√â BACKEND
        const BASE_COORDS = {
            lat: 48.853229,
            lon: 2.225328
        };

        // Zones de surveillance (en m√®tres)
        const ZONES_BASE = {
            ALERTE: 1000,       // 1km - zone d'alerte (rouge)
            VIGILANCE: 2000,    // 2km - zone de vigilance (orange)
            APPROCHE: 3000      // 3km - zone d'approche (vert)
        };

        // Constantes am√©lior√©es
        const REFRESH_NORMAL = 10; // 10 secondes en mode normal
        const REFRESH_ALERTE = 2;  // 2 secondes si navires en zone rouge

        // Variables globales
        let map;
        let navires = [];
        let naviresNonConformes = [];
        let markers = [];
        let cercles = [];
        let baseMarker;
        let surveillanceActive = false;
        let intervalleRefresh;
        let intervalleCompteur;
        let tempsRestant = REFRESH_NORMAL;
        let naviresEnAlerte = new Set();
        let naviresTrackes = new Map(); // MMSI -> donn√©es de tracking
        let coordsActuelles = {...BASE_COORDS};
        let modeActualisation = 'normal'; // 'normal' ou 'alerte'

        // ===== SYST√àME DE NUM√âROTATION CONFORME RGPD =====
        let naviresNumerotes = new Map(); // MMSI -> {numero, dateAttribution}
        let prochainNumero = 1;
        let derniereReinitialisation = null;

        // ===== STABILISATION NUM√âROTATION =====
        let historiqueVitesses = new Map(); // MMSI -> {scans, scansMouvement, scansArret, dernierScan, derniereVitesse}
        const SCANS_REQUIS_MOUVEMENT = 2; // 2 scans cons√©cutifs > 0.5 kn pour attribution
        const SCANS_DELAI_GRACE = 2; // 2 scans de tol√©rance avant retrait num√©ro

        // ===== COMPTEUR JOURNALIER =====
        let compteurJournalier = {
            derniereReinitialisation: null,
            joursHistorique: [],
            jourActuel: null
        };

        // ===== FORMATAGE DES DATES =====
        function formaterDateFr(dateString) {
            const date = new Date(dateString);
            const options = { day: 'numeric', month: 'long', year: 'numeric' };
            return date.toLocaleDateString('fr-FR', options);
        }

        function formaterDateCourteFr(dateString) {
            const date = new Date(dateString);
            const options = { day: '2-digit', month: '2-digit' };
            return date.toLocaleDateString('fr-FR', options);
        }

        // ===== D√âTECTION TERRE/EAU =====
        const POLYGONE_SEINE_PARIS = [
            [48.890, 2.210], // Amont Ouest
            [48.885, 2.250], // Amont Est
            [48.850, 2.280], // Centre Est
            [48.820, 2.260], // Aval Est
            [48.825, 2.200], // Aval Ouest
            [48.860, 2.180], // Centre Ouest
            [48.890, 2.210]  // Fermeture polygone
        ];

        // Initialisation du syst√®me de num√©rotation
        async function initialiserNumerotation() {
            const aujourdhui = new Date().toDateString();

            // R√©cup√©ration depuis localStorage - SEULEMENT le compteur journalier
            const donneesStockees = localStorage.getItem('trackship_compteur');
            if (donneesStockees) {
                try {
                    const donnees = JSON.parse(donneesStockees);

                    // V√©rifier si c'est le m√™me jour
                    if (donnees.date === aujourdhui) {
                        prochainNumero = donnees.prochainNumero || 1;
                        derniereReinitialisation = donnees.date;
                        console.log(`üìã Compteur journalier restaur√©: prochain num√©ro ${prochainNumero}`);
                    } else {
                        console.log('üìÖ Nouvelle journ√©e d√©tect√©e, reset du compteur');
                        reinitialiserNumerotation();
                    }
                } catch (e) {
                    console.warn('‚ö†Ô∏è Erreur lors de la restauration du compteur:', e);
                    reinitialiserNumerotation();
                }
            } else {
                reinitialiserNumerotation();
            }

            // IMPORTANT: Les navires ne sont jamais sauvegard√©s, seul le compteur l'est
            naviresNumerotes.clear();
            console.log('üóëÔ∏è M√©moire des navires vid√©e (conforme RGPD)');

            // Initialiser le compteur journalier (async)
            await initialiserCompteurJournalier();
        }

        // R√©initialisation du compteur pour une nouvelle journ√©e
        function reinitialiserNumerotation() {
            naviresNumerotes.clear();
            prochainNumero = 1;
            derniereReinitialisation = new Date().toDateString();
            sauvegarderCompteur();
            console.log('üîÑ Compteur journalier r√©initialis√©');
        }

        // Sauvegarde UNIQUEMENT du compteur (pas des navires - RGPD)
        function sauvegarderCompteur() {
            try {
                const donnees = {
                    date: derniereReinitialisation,
                    prochainNumero: prochainNumero
                    // PAS de sauvegarde des navires pour respecter RGPD
                };
                localStorage.setItem('trackship_compteur', JSON.stringify(donnees));
            } catch (e) {
                console.warn('‚ö†Ô∏è Erreur lors de la sauvegarde du compteur:', e);
            }
        }

        // ===== SYST√àME COMPTEUR JOURNALIER =====

        async function initialiserCompteurJournalier() {
            try {
                const response = await fetch('api/compteur.php?action=get_current');
                const data = await response.json();

                if (data.error) {
                    console.error('‚ùå Erreur initialisation compteur:', data.error);
                    return;
                }

                compteurJournalier = {
                    jourActuel: {
                        numeroJour: data.numero_jour,
                        date: data.date_jour,
                        compteur: data.compteur_passages,
                        bateauxActuellementEnZoneRouge: data.bateaux_zone_rouge || []
                    }
                };

                const dateFormatee = formaterDateCourteFr(data.date_jour);
                console.log(`üìä Compteur initialis√©: ${dateFormatee}, ${data.compteur_passages} passages`);

                // Afficher le panneau imm√©diatement apr√®s initialisation
                await afficherPanneauCompteur();
            } catch (error) {
                console.error('‚ùå Erreur connexion API compteur:', error);
            }
        }

        function reinitialiserCompteurJournalier() {
            // Fonction conserv√©e pour compatibilit√© mais non utilis√©e avec MySQL
            console.log('‚ö†Ô∏è reinitialiserCompteurJournalier() - Non utilis√© avec MySQL');
        }

        function sauvegarderCompteurJournalier() {
            // Fonction conserv√©e pour compatibilit√© - La sauvegarde est automatique via API
        }

        async function gererComptageZoneRouge(naviresActuels) {
            if (!compteurJournalier.jourActuel) return;

            const bateauxEnZoneRougeActuellement = [];
            const bateauxEntrantDansZone = [];

            // D√©tecter les navires en zone rouge (‚â§ 1000m)
            naviresActuels.forEach(navire => {
                const trackId = navire.trackId?.toString() || navire.mmsi?.toString();
                if (!trackId) return;

                const analyse = analyserNavire(navire);
                if (analyse.statut === 'alerte' && analyse.distance <= 1000) {
                    bateauxEnZoneRougeActuellement.push(trackId);

                    // V√©rifier si c'est une ENTR√âE en zone rouge
                    if (!compteurJournalier.jourActuel.bateauxActuellementEnZoneRouge.includes(trackId)) {
                        bateauxEntrantDansZone.push({
                            trackId: trackId,
                            shipName: navire.shipName || `Track ${trackId}`
                        });
                    }
                }
            });

            // Envoyer les entr√©es √† l'API
            if (bateauxEntrantDansZone.length > 0) {
                for (const bateau of bateauxEntrantDansZone) {
                    try {
                        const response = await fetch('api/compteur.php?action=increment', {
                            method: 'POST',
                            headers: {'Content-Type': 'application/json'},
                            body: JSON.stringify(bateau)
                        });

                        const result = await response.json();
                        if (result.success) {
                            // Mettre √† jour le compteur local
                            compteurJournalier.jourActuel.compteur = result.compteur;
                            console.log(`üî¥ ENTR√âE zone rouge: ${bateau.shipName} (${bateau.trackId}) - Compteur: ${result.compteur}`);
                        }
                    } catch (error) {
                        console.error('‚ùå Erreur incr√©mentation compteur:', error);
                    }
                }
            }

            // Mettre √† jour la liste des bateaux actifs en zone rouge via API
            try {
                await fetch('api/compteur.php?action=update_zone_rouge', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({trackIds: bateauxEnZoneRougeActuellement})
                });

                compteurJournalier.jourActuel.bateauxActuellementEnZoneRouge = bateauxEnZoneRougeActuellement;
            } catch (error) {
                console.error('‚ùå Erreur mise √† jour zone rouge:', error);
            }

            // Rafra√Æchir l'affichage
            await afficherPanneauCompteur();
        }

        async function afficherPanneauCompteur() {
            const panneauElement = document.getElementById('panneauCompteurJournalier');
            if (!panneauElement || !compteurJournalier.jourActuel) return;

            try {
                // R√©cup√©rer l'historique depuis l'API
                const response = await fetch('api/compteur.php?action=get_history');
                const data = await response.json();

                if (data.error) {
                    console.error('‚ùå Erreur chargement historique:', data.error);
                    return;
                }

                const jourActuel = compteurJournalier.jourActuel;
                const historique = data.historique.filter(j => parseInt(j.numero_jour) !== jourActuel.numeroJour).reverse();
                const totalCumule = data.total_cumule;

                let htmlHistorique = '';
                historique.forEach(jour => {
                    const dateFormatee = formaterDateCourteFr(jour.date_jour);
                    htmlHistorique += `
                        <div class="jour-item">
                            <span class="jour-numero">${dateFormatee}</span>
                            <span class="jour-valeur">${jour.compteur_passages} passage${jour.compteur_passages > 1 ? 's' : ''}</span>
                        </div>
                    `;
                });

                const dateAujourdhui = formaterDateFr(jourActuel.date);
                const nbJours = historique.length + 1; // +1 pour le jour actuel

                panneauElement.innerHTML = `
                    <h3>üìä Compteur de passages - Zone Rouge</h3>
                    <div class="compteur-jour-actuel">
                        <div class="jour-label">${dateAujourdhui} (Aujourd'hui)</div>
                        <div class="jour-compteur">${jourActuel.compteur} passage${jourActuel.compteur > 1 ? 's' : ''}</div>
                    </div>
                    <div class="compteur-total">
                        <strong>Total cumul√©:</strong> ${totalCumule} passages sur ${nbJours} jour${nbJours > 1 ? 's' : ''}
                    </div>
                    ${historique.length > 0 ? `
                        <div class="compteur-historique-toggle" onclick="toggleHistorique()">
                            <span id="historique-icon">‚ñ∂</span> Voir l'historique (${historique.length} jour${historique.length > 1 ? 's' : ''})
                        </div>
                        <div class="compteur-historique" id="historiqueContent" style="display: none;">
                            ${htmlHistorique}
                        </div>
                    ` : ''}
                    <button class="btn-effacer-historique" onclick="ouvrirMenuEffacement()">
                        üóëÔ∏è Effacer des donn√©es
                    </button>
                `;
            } catch (error) {
                console.error('‚ùå Erreur affichage compteur:', error);
            }
        }

        function toggleHistorique() {
            const content = document.getElementById('historiqueContent');
            const icon = document.getElementById('historique-icon');
            if (content.style.display === 'none') {
                content.style.display = 'block';
                icon.textContent = '‚ñº';
            } else {
                content.style.display = 'none';
                icon.textContent = '‚ñ∂';
            }
        }

        async function ouvrirMenuEffacement() {
            try {
                // R√©cup√©rer l'historique pour afficher les dates disponibles
                const response = await fetch('api/compteur.php?action=get_history');
                const data = await response.json();

                if (data.error) {
                    alert('‚ùå Erreur lors du chargement de l\'historique');
                    return;
                }

                const historique = data.historique.reverse(); // Plus ancien au plus r√©cent

                if (historique.length === 0) {
                    alert('‚ÑπÔ∏è Aucun historique √† effacer (seul le jour actuel existe)');
                    return;
                }

                // Cr√©er la liste des dates disponibles
                let listeDates = '\nDates disponibles :\n';
                historique.forEach((jour, index) => {
                    const dateFormatee = formaterDateCourteFr(jour.date_jour);
                    listeDates += `${index + 1}. ${dateFormatee} (${jour.compteur_passages} passage${jour.compteur_passages > 1 ? 's' : ''})\n`;
                });

                const message = `üóëÔ∏è Effacer l'historique des passages\n\n` +
                    `Entrez le(s) num√©ro(s) √† effacer :\n\n` +
                    `Format : "1-5" (de la date 1 √† la date 5)\n` +
                    `ou "3" (uniquement la date 3)\n` +
                    `ou "tout" (effacer TOUT l'historique)\n` +
                    listeDates;

                const reponse = prompt(message);
                if (!reponse) return; // Annul√©

                let requestBody = {};

                if (reponse.toLowerCase() === 'tout') {
                    if (!confirm('‚ö†Ô∏è ATTENTION : Voulez-vous vraiment effacer TOUT l\'historique ?\n\nCette action est irr√©versible !')) {
                        return;
                    }
                    requestBody = {type: 'all'};
                } else {
                    const rangMatch = reponse.match(/^(\d+)-(\d+)$/);
                    const singleMatch = reponse.match(/^(\d+)$/);

                    if (rangMatch) {
                        const indexDebut = parseInt(rangMatch[1]) - 1;
                        const indexFin = parseInt(rangMatch[2]) - 1;

                        if (indexDebut >= indexFin || indexDebut < 0 || indexFin >= historique.length) {
                            alert(`‚ùå Plage invalide ! Utilisez un format entre 1 et ${historique.length}`);
                            return;
                        }

                        const dateDebut = formaterDateCourteFr(historique[indexDebut].date_jour);
                        const dateFin = formaterDateCourteFr(historique[indexFin].date_jour);

                        if (!confirm(`‚ö†Ô∏è Effacer les donn√©es du ${dateDebut} au ${dateFin} ?\n\nCette action est irr√©versible !`)) {
                            return;
                        }

                        // R√©cup√©rer les numero_jour correspondants
                        const numeroDebut = historique[indexDebut].numero_jour;
                        const numeroFin = historique[indexFin].numero_jour;
                        requestBody = {type: 'range', debut: numeroDebut, fin: numeroFin};
                    } else if (singleMatch) {
                        const index = parseInt(singleMatch[1]) - 1;

                        if (index < 0 || index >= historique.length) {
                            alert(`‚ùå Num√©ro invalide ! Choisissez entre 1 et ${historique.length}`);
                            return;
                        }

                        const dateAEffacer = formaterDateCourteFr(historique[index].date_jour);

                        if (!confirm(`‚ö†Ô∏è Effacer les donn√©es du ${dateAEffacer} ?\n\nCette action est irr√©versible !`)) {
                            return;
                        }

                        const numeroJour = historique[index].numero_jour;
                        requestBody = {type: 'single', jour: numeroJour};
                    } else {
                        alert('‚ùå Format invalide !\n\nExemples valides :\n- "1-5" (plage)\n- "3" (date unique)\n- "tout" (tout effacer)');
                        return;
                    }
                }

                // Appel API pour effacer
                const deleteResponse = await fetch('api/compteur.php?action=delete_days', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(requestBody)
                });

                const result = await deleteResponse.json();

                if (result.success) {
                    alert(`‚úÖ ${result.message}`);
                    await afficherPanneauCompteur();
                } else {
                    alert(`‚ùå Erreur: ${result.error}`);
                }
            } catch (error) {
                console.error('‚ùå Erreur suppression:', error);
                alert('‚ùå Erreur lors de la suppression');
            }
        }

        // Nettoyage RGPD - Conservation des num√©ros pour navires dans la zone (m√™me √† l'arr√™t)
        function nettoyageRGPD(naviresPresentsDansZoneVerte) {
            const rayonSaisi = parseFloat(document.getElementById('rayon').value) || 3;
            let rayonZoneVerte = ZONES_BASE.APPROCHE;
            if (rayonSaisi > 3) {
                rayonZoneVerte = ZONES_BASE.APPROCHE * (rayonSaisi / 3);
            }

            // MMSI des navires qui doivent garder leur num√©ro
            const mmsiAGarder = new Set();
            
            // Parcourir tous les navires pr√©sents
            naviresPresentsDansZoneVerte.forEach(navire => {
                const mmsi = navire.mmsi?.toString();
                if (!mmsi) return;
                
                const distance = calculerDistance(
                    coordsActuelles.lat, coordsActuelles.lon,
                    navire.latitude, navire.longitude
                );
                
                // R√àGLE : Garder le num√©ro si le navire est DANS LA ZONE (peu importe s'il bouge ou pas)
                const dansZoneVerte = distance <= rayonZoneVerte;
                const estNonConformeEnMouvement = estNavireNonConformeEnMouvement(navire);
                
                if (dansZoneVerte || estNonConformeEnMouvement) {
                    mmsiAGarder.add(mmsi);
                    
                    // Mettre √† jour le timestamp si le navire est en mouvement
                    if (naviresNumerotes.has(mmsi) && estEnMouvementStabilise(navire)) {
                        const data = naviresNumerotes.get(mmsi);
                        data.dernierMouvement = new Date().toISOString();
                        naviresNumerotes.set(mmsi, data);
                    }
                }
            });
            
            const mmsiEnMemoireSupprimee = [];
            
            // Supprimer les navires qui ont QUITT√â LA ZONE
            naviresNumerotes.forEach((data, mmsi) => {
                if (!mmsiAGarder.has(mmsi)) {
                    naviresNumerotes.delete(mmsi);
                    mmsiEnMemoireSupprimee.push(mmsi);
                }
            });
            
            if (mmsiEnMemoireSupprimee.length > 0) {
                console.log(`üóëÔ∏è RGPD: ${mmsiEnMemoireSupprimee.length} navire(s) oubli√©(s) (sortis de zone)`);
            }
        }

        // Nettoyage de l'historique des vitesses (navires sortis de zone)
        function nettoyageHistoriqueVitesses(naviresPresentsDansZoneVerte) {
            const mmsiPresents = new Set(
                naviresPresentsDansZoneVerte
                    .filter(n => n.mmsi)
                    .map(n => n.mmsi.toString())
            );

            let compteurSuppression = 0;
            historiqueVitesses.forEach((data, mmsi) => {
                if (!mmsiPresents.has(mmsi)) {
                    historiqueVitesses.delete(mmsi);
                    compteurSuppression++;
                }
            });

            if (compteurSuppression > 0) {
                console.log(`üßπ Historique vitesses nettoy√©: ${compteurSuppression} navire(s) oubli√©(s)`);
            }
        }

        // Attribution d'un num√©ro √† un navire EN MOUVEMENT uniquement
        function attribuerNumero(navire) {
            // V√©rifier si nouvelle journ√©e
            const aujourdhui = new Date().toDateString();
            if (derniereReinitialisation !== aujourdhui) {
                reinitialiserNumerotation();
            }

            const mmsi = navire.mmsi?.toString();
            if (!mmsi) {
                console.log(`‚ö†Ô∏è Pas de MMSI pour ${navire.shipName}`);
                return null;
            }

            // NOUVEAU : Seuls les navires EN MOUVEMENT peuvent avoir/garder un num√©ro
            const enMouvement = estEnMouvementStabilise(navire);
            if (!enMouvement) {
                console.log(`‚è∏Ô∏è ${navire.shipName} √† l'arr√™t (vitesse: ${navire.speed}) - pas de nouveau num√©ro`);
                return null; // Pas de num√©ro pour les navires √† l'arr√™t
            }

            // Si le navire a d√©j√† un num√©ro, le retourner
            if (naviresNumerotes.has(mmsi)) {
                const numero = naviresNumerotes.get(mmsi).numero;
                console.log(`‚ôªÔ∏è ${navire.shipName} r√©cup√®re son num√©ro #${numero}`);
                return numero;
            }

            // V√©rifier si le navire est dans la zone verte (zone d'approche)
            const distance = calculerDistance(
                coordsActuelles.lat, coordsActuelles.lon,
                navire.latitude, navire.longitude
            );

            const rayonSaisi = parseFloat(document.getElementById('rayon').value) || 3;
            let rayonZoneVerte = ZONES_BASE.APPROCHE;
            if (rayonSaisi > 3) {
                rayonZoneVerte = ZONES_BASE.APPROCHE * (rayonSaisi / 3);
            }

            // Attribution du num√©ro si dans la zone verte OU navire non conforme en mouvement
            const dansZoneVerte = distance <= rayonZoneVerte;
            const estNonConformeEnMouvement = estNavireNonConformeEnMouvement(navire);
            
            console.log(`üîç ${navire.shipName} - Distance: ${Math.round(distance)}m - Zone: ${Math.round(rayonZoneVerte)}m - Dans zone: ${dansZoneVerte} - Non conforme: ${estNonConformeEnMouvement}`);
            
            if (dansZoneVerte || estNonConformeEnMouvement) {
                const nouveauNumero = prochainNumero;
                naviresNumerotes.set(mmsi, {
                    numero: nouveauNumero,
                    dateAttribution: new Date().toISOString(),
                    dernierMouvement: new Date().toISOString() // Pour tracking
                });
                
                prochainNumero++;
                sauvegarderCompteur();
                console.log(`üè∑Ô∏è ‚úÖ Nouveau num√©ro attribu√©: #${nouveauNumero} √† "${navire.shipName}" (${mmsi}) - ${estNonConformeEnMouvement ? 'Non conforme' : 'Zone verte'}`);
                return nouveauNumero;
            } else {
                console.log(`‚ùå ${navire.shipName} hors zone d'attribution (${Math.round(distance)}m > ${Math.round(rayonZoneVerte)}m)`);
            }

            return null;
        }

        // Num√©rotation initiale au d√©marrage - SEULEMENT navires EN MOUVEMENT, du plus loin au plus pr√®s
        function numerotationInitiale(tousLesNavires) {
            console.log('üéØ Num√©rotation initiale des navires EN MOUVEMENT pr√©sents');
            
            const rayonSaisi = parseFloat(document.getElementById('rayon').value) || 3;
            let rayonZoneVerte = ZONES_BASE.APPROCHE;
            if (rayonSaisi > 3) {
                rayonZoneVerte = ZONES_BASE.APPROCHE * (rayonSaisi / 3);
            }

            // Identifier les navires EN MOUVEMENT √† num√©roter
            const naviresANumeroter = tousLesNavires.filter(navire => {
                if (!navire.mmsi) return false;
                
                // OBLIGATOIRE : doit √™tre en mouvement
                const enMouvement = estEnMouvementStabilise(navire);
                if (!enMouvement) return false;
                
                const distance = calculerDistance(
                    coordsActuelles.lat, coordsActuelles.lon,
                    navire.latitude, navire.longitude
                );
                
                const dansZoneVerte = distance <= rayonZoneVerte;
                const estNonConformeEnMouvement = estNavireNonConformeEnMouvement(navire);
                
                return dansZoneVerte || estNonConformeEnMouvement;
            });

            // Trier par distance - DU PLUS LOIN AU PLUS PR√àS
            const naviresTries = naviresANumeroter.sort((a, b) => {
                const distA = calculerDistance(coordsActuelles.lat, coordsActuelles.lon, a.latitude, a.longitude);
                const distB = calculerDistance(coordsActuelles.lat, coordsActuelles.lon, b.latitude, b.longitude);
                return distB - distA; // Ordre d√©croissant = plus loin d'abord
            });

            // Attribution s√©quentielle
            let compteurInitial = 0;
            naviresTries.forEach(navire => {
                const mmsi = navire.mmsi?.toString();
                if (mmsi && !naviresNumerotes.has(mmsi)) {
                    const numeroAttribue = prochainNumero;
                    naviresNumerotes.set(mmsi, {
                        numero: numeroAttribue,
                        dateAttribution: new Date().toISOString(),
                        dernierMouvement: new Date().toISOString()
                    });
                    prochainNumero++;
                    compteurInitial++;
                    
                    const distance = Math.round(calculerDistance(coordsActuelles.lat, coordsActuelles.lon, navire.latitude, navire.longitude));
                    console.log(`üè∑Ô∏è #${numeroAttribue} ‚Üí "${navire.shipName}" (${distance}m) - EN MOUVEMENT`);
                }
            });
            
            if (compteurInitial > 0) {
                sauvegarderCompteur();
                console.log(`‚úÖ ${compteurInitial} navires EN MOUVEMENT num√©rot√©s au d√©marrage (du plus loin au plus pr√®s)`);
            }
        }

        // R√©cup√©ration du num√©ro d'un navire
        function obtenirNumeroNavire(navire) {
            const mmsi = navire.mmsi?.toString();
            if (!mmsi || !naviresNumerotes.has(mmsi)) return null;
            return naviresNumerotes.get(mmsi).numero;
        }

        console.log('üö¢ TrackShip charg√© sur trackship.bakabi.fr - Version avec num√©rotation persistante');

        // Fonction pour cr√©er une ic√¥ne directionnelle avec num√©ro (SEULEMENT si en mouvement)
        function creerIconeDirectionnelle(navire, analyse) {
            const enMouvement = estEnMouvementStabilise(navire);
            const surTerre = estEmetteurTerrestre(navire);
            const course = parseFloat(navire.course) || 0;

            // NOUVEAU : Le num√©ro ne s'affiche QUE si le navire est en mouvement
            const numeroNavire = enMouvement ? obtenirNumeroNavire(navire) : null;
            
            // Couleur selon le statut
            let couleur = analyse.couleur;
            let taille = enMouvement ? 32 : 24; // Plus grandes ic√¥nes
            let opacite = enMouvement ? 1 : 0.6;
            
            // Cr√©ation de l'ic√¥ne avec fl√®che directionnelle et num√©ro
            let iconeHtml;
            
            if (enMouvement && course !== null && course !== undefined) {
                // Navire en mouvement avec cap connu
                iconeHtml = `
                    <div style="
                        width: ${taille}px;
                        height: ${taille}px;
                        position: relative;
                        transform: rotate(${course}deg);
                    ">
                        <div style="
                            width: 0;
                            height: 0;
                            border-left: ${taille/3}px solid transparent;
                            border-right: ${taille/3}px solid transparent;
                            border-bottom: ${taille}px solid ${couleur};
                            position: absolute;
                            top: 0;
                            left: 50%;
                            transform: translateX(-50%);
                            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
                        "></div>
                        <div style="
                            position: absolute;
                            bottom: 4px;
                            left: 50%;
                            transform: translateX(-50%) rotate(-${course}deg);
                            font-size: 12px;
                            color: white;
                            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                        ">${surTerre ? 'üì°' : 'üö¢'}</div>
                    </div>
                `;
            } else {
                // Navire √† l'arr√™t ou sans cap - ic√¥ne circulaire classique
                iconeHtml = `
                    <div style="
                        background-color: ${couleur};
                        width: ${taille}px;
                        height: ${taille}px;
                        border-radius: 50%;
                        border: 3px solid white;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.3);
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 12px;
                        opacity: ${opacite};
                        position: relative;
                    ">${surTerre ? 'üì°' : 'üö¢'}</div>
                `;
            }

            // Ajout du num√©ro SEULEMENT si en mouvement ET a un num√©ro
            if (numeroNavire && enMouvement) {
                iconeHtml += `
                    <div style="
                        position: absolute;
                        top: -8px;
                        right: -8px;
                        background: #fff;
                        color: #333;
                        border: 2px solid ${couleur};
                        border-radius: 50%;
                        width: 20px;
                        height: 20px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        font-size: 10px;
                        font-weight: bold;
                        box-shadow: 0 2px 4px rgba(0,0,0,0.2);
                    ">#${numeroNavire}</div>
                `;
            }
            
            // Ajout de l'emoji d'alerte si n√©cessaire
            if (analyse.emoji) {
                iconeHtml += `<span style="position: absolute; top: ${(numeroNavire && enMouvement) ? '-12px' : '-8px'}; left: -8px; font-size: 16px; z-index: 1000;">${analyse.emoji}</span>`;
            }

            return L.divIcon({
                html: iconeHtml,
                iconSize: [taille + 8, taille + 8],
                iconAnchor: [taille/2 + 4, taille/2 + 4],
                popupAnchor: [0, -(taille/2 + 4)],
                className: 'navire-marker-directionnel'
            });
        }

        // Affichage du statut de connexion
        function afficherStatut(type, message) {
            const indicator = document.getElementById('statusIndicator');
            const text = document.getElementById('statusText');
            
            indicator.style.display = 'block';
            indicator.className = `status-indicator status-${type}`;
            text.textContent = message;
            
            console.log(`üìä Statut: ${type} - ${message}`);
        }

        // Affichage des messages dans la liste des navires
        function afficherMessage(type, titre, message, details = null) {
            const listeElement = document.getElementById('listeNavires');
            
            let detailsHtml = '';
            if (details) {
                if (typeof details === 'object') {
                    detailsHtml = `<div style="margin-top: 10px; font-size: 12px; color: #666;"><pre>${JSON.stringify(details, null, 2)}</pre></div>`;
                } else {
                    detailsHtml = `<div style="margin-top: 10px; font-size: 12px; color: #666;">${details}</div>`;
                }
            }
            
            listeElement.innerHTML = `
                <div class="${type}">
                    <strong>${titre}</strong><br>
                    ${message}
                    ${detailsHtml}
                </div>
            `;
        }

        // Initialisation de la carte
        function initMap() {
            console.log('üó∫Ô∏è Initialisation de la carte Leaflet');
            
            map = L.map('map').setView([coordsActuelles.lat, coordsActuelles.lon], 12);
            
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '¬© OpenStreetMap contributors'
            }).addTo(map);

            mettreAJourBase();
            console.log('‚úÖ Carte initialis√©e avec les zones de surveillance');
        }

        // Mise √† jour de la base et des cercles
        function mettreAJourBase() {
            if (baseMarker) {
                map.removeLayer(baseMarker);
            }
            
            cercles.forEach(cercle => map.removeLayer(cercle));
            cercles = [];

            // Marqueur de base
            const imageUrl = 'assets/1.png';
            
            const baseIcon = L.icon({
                iconUrl: imageUrl,
                iconSize: [32, 32],
                iconAnchor: [16, 16],
                popupAnchor: [0, -16]
            });
            
            const fallbackIcon = L.divIcon({
                html: 'üè≠',
                iconSize: [30, 30],
                className: 'base-marker'
            });
            
            baseMarker = L.marker([coordsActuelles.lat, coordsActuelles.lon], {icon: baseIcon})
                .addTo(map)
                .bindPopup('<b>üè≠ Base de surveillance</b><br>trackship.bakabi.fr<br>üìç Coordonn√©es verrouill√©es c√¥t√© serveur');
            
            baseMarker.on('error', function() {
                baseMarker.setIcon(fallbackIcon);
            });

            // Calcul des rayons avec correction GPS
            const rayonSaisi = parseFloat(document.getElementById('rayon').value) || 5;
            let rayons = {...ZONES_BASE};
            
            if (rayonSaisi > 3) {
                const facteur = rayonSaisi / 3;
                rayons.ALERTE = ZONES_BASE.ALERTE * facteur;
                rayons.VIGILANCE = ZONES_BASE.VIGILANCE * facteur;
                rayons.APPROCHE = ZONES_BASE.APPROCHE * facteur;
            }

            // Cr√©ation des cercles
            const cercleAlerte = L.circle([coordsActuelles.lat, coordsActuelles.lon], {
                color: '#dc3545',
                fillColor: '#dc3545',
                fillOpacity: 0.2,
                radius: rayons.ALERTE,
                weight: 3
            }).addTo(map).bindPopup(`Zone d'alerte (${Math.round(rayons.ALERTE/1000*10)/10}km) - Suivi 2s`);
            cercles.push(cercleAlerte);

            const cercleVigilance = L.circle([coordsActuelles.lat, coordsActuelles.lon], {
                color: '#fd7e14',
                fillColor: '#fd7e14',
                fillOpacity: 0.15,
                radius: rayons.VIGILANCE,
                weight: 2
            }).addTo(map).bindPopup(`Zone de vigilance (${Math.round(rayons.VIGILANCE/1000*10)/10}km)`);
            cercles.push(cercleVigilance);

            const cercleApproche = L.circle([coordsActuelles.lat, coordsActuelles.lon], {
                color: '#28a745',
                fillColor: '#28a745',
                fillOpacity: 0.1,
                radius: rayons.APPROCHE,
                weight: 2,
                dashArray: '5, 5'
            }).addTo(map).bindPopup(`Zone d'approche (${Math.round(rayons.APPROCHE/1000*10)/10}km) - Attribution num√©ros`);
            cercles.push(cercleApproche);

            if (rayonSaisi > 3) {
                const cercleSurveillance = L.circle([coordsActuelles.lat, coordsActuelles.lon], {
                    color: '#6c757d',
                    fillColor: 'transparent',
                    fillOpacity: 0,
                    radius: rayonSaisi * 1000,
                    weight: 1,
                    dashArray: '10, 10'
                }).addTo(map).bindPopup(`Zone de surveillance g√©n√©rale (${rayonSaisi}km)`);
                cercles.push(cercleSurveillance);
            }
        }

        // Calcul de la distance (formule de Haversine) - Correction GPS appliqu√©e
        function calculerDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Rayon de la Terre en m√®tres
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }

        // ===== D√âTECTION TERRE/EAU =====

        // Algorithme ray-casting pour point dans polygone
        function estSurEau(latitude, longitude) {
            const polygone = POLYGONE_SEINE_PARIS;

            let inside = false;
            for (let i = 0, j = polygone.length - 1; i < polygone.length; j = i++) {
                const xi = polygone[i][0], yi = polygone[i][1];
                const xj = polygone[j][0], yj = polygone[j][1];

                const intersect = ((yi > longitude) !== (yj > longitude))
                    && (latitude < (xj - xi) * (longitude - yi) / (yj - yi) + xi);

                if (intersect) inside = !inside;
            }

            return inside;
        }

        // V√©rification si navire est un √©metteur terrestre
        function estEmetteurTerrestre(navire) {
            if (!navire.latitude || !navire.longitude) return false;
            return !estSurEau(navire.latitude, navire.longitude);
        }

        // V√©rification si navire en mouvement - VERSION STABILIS√âE avec historique
        function estEnMouvementStabilise(navire) {
            const vitesse = parseFloat(navire.speed) || 0;
            const mmsi = navire.mmsi?.toString();

            if (!mmsi) {
                // Pas de MMSI = pas de tracking possible, d√©cision instantan√©e
                return vitesse > 0.5;
            }

            // Initialiser l'historique si premier scan
            if (!historiqueVitesses.has(mmsi)) {
                historiqueVitesses.set(mmsi, {
                    scans: [],
                    scansMouvement: 0,
                    scansArret: 0,
                    dernierScan: Date.now(),
                    derniereVitesse: vitesse
                });
            }

            const historique = historiqueVitesses.get(mmsi);
            const estAuDessusSeuil = vitesse > 0.5;

            // Mise √† jour de l'historique
            historique.scans.push(vitesse);
            if (historique.scans.length > 3) {
                historique.scans.shift(); // Garder seulement 3 derniers scans
            }

            // Compteur de scans cons√©cutifs
            if (estAuDessusSeuil) {
                historique.scansMouvement++;
                historique.scansArret = 0;
            } else {
                historique.scansArret++;
                historique.scansMouvement = 0;
            }

            historique.dernierScan = Date.now();
            historique.derniereVitesse = vitesse;
            historiqueVitesses.set(mmsi, historique);

            // R√àGLE DE STABILISATION
            // 1. Attribution : 2 scans cons√©cutifs > 0.5 kn
            // 2. Retrait : 2 scans cons√©cutifs ‚â§ 0.5 kn (d√©lai de gr√¢ce)

            let enMouvementStabilise = false;

            if (historique.scansMouvement >= SCANS_REQUIS_MOUVEMENT) {
                // En mouvement confirm√©
                enMouvementStabilise = true;
            } else if (historique.scansArret < SCANS_DELAI_GRACE) {
                // D√©lai de gr√¢ce : encore consid√©r√© en mouvement si avait un num√©ro
                if (naviresNumerotes.has(mmsi)) {
                    enMouvementStabilise = true;
                }
            }

            if (navire.shipName) {
                console.log(`üö¢ ${navire.shipName} - V:${vitesse.toFixed(1)}kn - Scans‚Üë:${historique.scansMouvement} Scans‚Üì:${historique.scansArret} - Mouvement:${enMouvementStabilise}`);
            }

            return enMouvementStabilise;
        }

        // V√©rification si navire conforme aux crit√®res d'affichage
        function estNavireConforme(navire) {
            // Crit√®res de conformit√© (modifiables selon vos besoins)
            const aVitesse = navire.speed !== null && navire.speed !== undefined;
            const aNom = navire.shipName && navire.shipName.trim() !== '';
            const aLongueur = navire.length && parseFloat(navire.length) > 0;
            const aMMSI = navire.mmsi && navire.mmsi.toString().length >= 6;
            
            // Un navire est conforme s'il a au moins un nom et un MMSI valide
            return aNom && aMMSI;
        }

        // V√©rification si navire non conforme peut √™tre en mouvement
        function estNavireNonConformeEnMouvement(navire) {
            // Doit avoir une vitesse ET √™tre en mouvement (> 0.5 kn)
            const aVitesse = navire.speed !== null && navire.speed !== undefined && parseFloat(navire.speed) > 0.5;
            
            // Manque au moins une donn√©e critique (nom, MMSI ou longueur)
            const manqueNom = !navire.shipName || navire.shipName.trim() === '';
            const manqueMMSI = !navire.mmsi || navire.mmsi.toString().length < 6;
            const manqueLongueur = !navire.length || parseFloat(navire.length) <= 0;
            
            // Non conforme = manque des donn√©es ET peut bouger (a une vitesse > 0)
            return aVitesse && (manqueNom || manqueMMSI || manqueLongueur);
        }

        // Analyse du niveau de danger
        function analyserNavire(navire) {
            const distance = calculerDistance(
                coordsActuelles.lat, coordsActuelles.lon,
                navire.latitude, navire.longitude
            );

            const rayonSaisi = parseFloat(document.getElementById('rayon').value) || 5;
            let rayons = {...ZONES_BASE};
            
            if (rayonSaisi > 3) {
                const facteur = rayonSaisi / 3;
                rayons.ALERTE = ZONES_BASE.ALERTE * facteur;
                rayons.VIGILANCE = ZONES_BASE.VIGILANCE * facteur;
                rayons.APPROCHE = ZONES_BASE.APPROCHE * facteur;
            }

            let statut = 'approche';
            let couleur = '#28a745';
            let emoji = '';
            let classeCSS = 'navire-normal';
            let classeDistance = 'distance-normal';

            if (distance <= rayons.ALERTE) {
                statut = 'alerte';
                couleur = '#dc3545';
                emoji = 'üö®';
                classeCSS = 'navire-alerte';
                classeDistance = 'distance-alerte';
            } else if (distance <= rayons.VIGILANCE) {
                statut = 'vigilance';
                couleur = '#fd7e14';
                emoji = '‚ö†Ô∏è';
                classeCSS = 'navire-vigilance';
                classeDistance = 'distance-vigilance';
            }

            return {
                distance: Math.round(distance),
                statut,
                couleur,
                emoji,
                classeCSS,
                classeDistance
            };
        }

        // Gestion du tracking des navires en zone rouge
        function gererTrackingZoneRouge() {
            const naviresAlerteEnMouvement = navires.filter(navire => {
                const analyse = analyserNavire(navire);
                return analyse.statut === 'alerte' && estEnMouvementStabilise(navire) && navire.mmsi;
            });

            // Mise √† jour de la liste de tracking
            const anciennesClefs = new Set(naviresTrackes.keys());
            const nouvellesClefs = new Set();

            naviresAlerteEnMouvement.forEach(navire => {
                const mmsi = navire.mmsi.toString();
                nouvellesClefs.add(mmsi);
                
                if (!naviresTrackes.has(mmsi)) {
                    naviresTrackes.set(mmsi, {
                        navire: navire,
                        debutTracking: Date.now(),
                        dernierePosition: {lat: navire.latitude, lon: navire.longitude},
                        historique: []
                    });
                    console.log(`üéØ D√©but du tracking: ${navire.shipName} (${mmsi})`);
                } else {
                    // Mise √† jour des donn√©es
                    const tracking = naviresTrackes.get(mmsi);
                    tracking.navire = navire;
                    tracking.historique.push({
                        timestamp: Date.now(),
                        lat: navire.latitude,
                        lon: navire.longitude,
                        speed: navire.speed,
                        course: navire.course
                    });
                    tracking.dernierePosition = {lat: navire.latitude, lon: navire.longitude};
                }
            });

            // Suppression des navires qui ne sont plus en zone rouge
            anciennesClefs.forEach(mmsi => {
                if (!nouvellesClefs.has(mmsi)) {
                    const tracking = naviresTrackes.get(mmsi);
                    console.log(`‚èπÔ∏è Fin du tracking: ${tracking.navire.shipName} (${mmsi})`);
                    naviresTrackes.delete(mmsi);
                }
            });

            // D√©terminer le mode d'actualisation
            const nouveauMode = naviresTrackes.size > 0 ? 'alerte' : 'normal';
            if (modeActualisation !== nouveauMode) {
                modeActualisation = nouveauMode;
                const nouveauTemps = modeActualisation === 'alerte' ? REFRESH_ALERTE : REFRESH_NORMAL;
                tempsRestant = nouveauTemps;
                
                document.getElementById('modeActualisation').textContent = 
                    `Mode: ${modeActualisation === 'alerte' ? 'ALERTE (2s)' : 'Normal (10s)'}`;
                
                console.log(`üîÑ Mode actualisation: ${modeActualisation} (${nouveauTemps}s)`);
            }
        }

        // Panneau d'attention pour navires en mouvement < 2km - VERSION SIDEBAR
        function afficherPanneauAttentionSidebar(naviresVigilance) {
            const panneauElement = document.getElementById('panneauAttentionSidebar');
            const contenuElement = document.getElementById('contenuPanneauAttention');

            const naviresEnMouvementVigilance = naviresVigilance.filter(navire => estEnMouvementStabilise(navire));

            if (naviresEnMouvementVigilance.length === 0) {
                panneauElement.style.display = 'none';
                return;
            }

            console.log('‚ö†Ô∏è Panneau attention sidebar pour', naviresEnMouvementVigilance.length, 'navire(s) en mouvement');
            
            panneauElement.style.display = 'block';
            
            let contenuPanneau = '';
            
            naviresEnMouvementVigilance.forEach(navire => {
                const analyse = analyserNavire(navire);
                const cap = navire.course ? `${Math.round(navire.course)}¬∞` : 'N/A';
                const numeroNavire = obtenirNumeroNavire(navire);
                const numeroText = numeroNavire ? `#${numeroNavire}` : '';
                
                contenuPanneau += `
                    <div class="navire-panneau-sidebar">
                        <div style="font-size: 14px; margin-bottom: 5px;">
                            <strong>"${navire.shipName || 'Inconnu'}" ${numeroText}</strong> üîÑ
                        </div>
                        <div style="font-size: 12px; opacity: 0.9; display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                            <span>Distance: <strong>${analyse.distance}m</strong></span>
                            <span>Vitesse: <strong>${navire.speed || 'N/A'} kn</strong></span>
                            <span>Cap: <strong>${cap}</strong></span>
                            <span>Longueur: <strong>${navire.length || 'N/A'} m</strong></span>
                        </div>
                    </div>
                `;
            });
            
            contenuElement.innerHTML = contenuPanneau;
            
            // Scroll automatique vers le panneau si n√©cessaire
            setTimeout(() => {
                panneauElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }, 100);
        }

        // Alerte rouge pour navires en mouvement < 1km
        function declencherAlerteRouge(navire) {
            console.log('üö® Alerte rouge pour navire en mouvement:', navire.shipName);
            
            const ancienneBanniere = document.getElementById('banniereAlerte');
            if (ancienneBanniere) {
                ancienneBanniere.remove();
            }

            const analyse = analyserNavire(navire);
            const cap = navire.course ? `${Math.round(navire.course)}¬∞` : 'N/A';
            const numeroNavire = obtenirNumeroNavire(navire);
            const numeroText = numeroNavire ? `#${numeroNavire} ` : '';
            
            const banniere = document.createElement('div');
            banniere.id = 'banniereAlerte';
            banniere.className = 'banniere-alerte';
            banniere.innerHTML = `
                üö® ALERTE ZONE 1KM üö® - Navire ${numeroText}"${navire.shipName || 'Inconnu'}" en mouvement ! 
                Distance: ${analyse.distance}m - Vitesse: ${navire.speed || 'N/A'} kn - Cap: ${cap}
            `;
            
            document.body.insertBefore(banniere, document.body.firstChild);
            
            setTimeout(() => {
                if (document.getElementById('banniereAlerte')) {
                    banniere.remove();
                }
            }, 10000);

            // Notification sonore
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('üîá Notification sonore non disponible');
            }
        }

        // Filtrage des navires
        function filtrerNavires(navires) {
            const filtre = document.getElementById('filtreNavires').value;
            
            switch (filtre) {
                case 'mouvement':
                    return navires.filter(navire => estEnMouvementStabilise(navire));
                case 'arret':
                    return navires.filter(navire => !estEnMouvementStabilise(navire));
                case 'tous':
                default:
                    return navires;
            }
        }

        // Mise √† jour des marqueurs sur la carte
        function mettreAJourMarqueurs() {
            console.log('üó∫Ô∏è Mise √† jour des marqueurs');
            
            markers.forEach(function(marker) {
                map.removeLayer(marker);
            });
            markers = [];

            const naviresAfficher = filtrerNavires(navires);

            naviresAfficher.forEach(function(navire) {
                const analyse = analyserNavire(navire);
                const enMouvement = estEnMouvementStabilise(navire);
                const surTerre = estEmetteurTerrestre(navire);
                const numeroNavire = obtenirNumeroNavire(navire);

                // Utiliser la fonction creerIconeDirectionnelle qui existe d√©j√†
                const iconeNavire = creerIconeDirectionnelle(navire, analyse);

                const statutTexte = enMouvement ? 'EN MOUVEMENT' : '√Ä L\'ARR√äT';
                const typeLabel = surTerre ? '√âmetteur terrestre' : 'Navire';
                const nomNavire = navire.shipName || (surTerre ? '√âmetteur inconnu' : 'Navire inconnu');
                const vitesse = navire.speed || 'N/A';
                const longueur = navire.length || 'N/A';
                const mmsi = navire.mmsi || 'N/A';
                const typeNavire = navire.shipType || typeLabel;
                const cap = navire.course ? Math.round(navire.course) + '¬∞' : 'N/A';
                const numeroText = numeroNavire && enMouvement ? '#' + numeroNavire : '';
                const emoji = surTerre ? 'üì°' : 'üö¢';

                const popupContent = '<div style="min-width: 200px;"><h4 style="margin: 0 0 10px 0; color: ' + analyse.couleur + ';">' + numeroText + (numeroText ? ' - ' : '') + emoji + ' ' + nomNavire + ' ' + analyse.emoji + '</h4>' + (surTerre ? '<div style="background: #fff3cd; padding: 5px; border-radius: 4px; margin-bottom: 8px; font-weight: bold; color: #856404;">‚ö†Ô∏è Type: √âmetteur terrestre</div>' : '') + '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px; font-size: 12px;"><div><strong>Vitesse:</strong> ' + vitesse + ' kn</div><div><strong>Cap:</strong> ' + cap + '</div><div><strong>Longueur:</strong> ' + longueur + ' m</div><div><strong>MMSI:</strong> ' + mmsi + '</div><div><strong>Type:</strong> ' + typeLabel + '</div><div><strong>Distance:</strong> ' + analyse.distance + 'm</div><div><strong>Statut:</strong> <span style="color: ' + analyse.couleur + '; font-weight: bold;">' + statutTexte + '</span></div></div><div style="margin-top: 8px; font-size: 11px; color: #666;">üìç ' + navire.latitude.toFixed(6) + ', ' + navire.longitude.toFixed(6) + '</div></div>';

                const marker = L.marker([navire.latitude, navire.longitude], {icon: iconeNavire})
                    .addTo(map)
                    .bindPopup(popupContent);
                
                markers.push(marker);
            });

            console.log('‚úÖ ' + markers.length + ' marqueurs ajout√©s');
        }
        // Mise √† jour de la liste des navires conformes
        function mettreAJourListeNavires() {
            console.log('üìã Mise √† jour de la liste des navires');
            
            const listeElement = document.getElementById('listeNavires');
            const naviresAfficher = filtrerNavires(navires);
            
            if (naviresAfficher.length === 0) {
                const filtre = document.getElementById('filtreNavires').value;
                let message = 'Aucun navire d√©tect√© dans la zone';
                if (filtre === 'mouvement') {
                    message = 'Aucun navire en mouvement d√©tect√©';
                } else if (filtre === 'arret') {
                    message = 'Aucun navire √† l\'arr√™t d√©tect√©';
                }
                listeElement.innerHTML = `<div class="loading">${message}</div>`;
                return;
            }

            // Tri par distance
            const naviresTries = [...naviresAfficher].sort((a, b) => {
                const distA = calculerDistance(coordsActuelles.lat, coordsActuelles.lon, a.latitude, a.longitude);
                const distB = calculerDistance(coordsActuelles.lat, coordsActuelles.lon, b.latitude, b.longitude);
                return distA - distB;
            });

            const htmlNavires = naviresTries.map(navire => {
                const analyse = analyserNavire(navire);
                const enMouvement = estEnMouvementStabilise(navire);
                const surTerre = estEmetteurTerrestre(navire);
                const estTracke = naviresTrackes.has(navire.mmsi?.toString());
                const cap = navire.course ? `${Math.round(navire.course)}¬∞` : 'N/A';
                const numeroNavire = obtenirNumeroNavire(navire);
                const numeroText = numeroNavire && enMouvement ? `#${numeroNavire}` : '';
                const emoji = surTerre ? 'üì°' : 'üö¢';
                const nomNavire = navire.shipName || (surTerre ? '√âmetteur inconnu' : 'Navire inconnu');

                return `
                    <div class="navire-item ${analyse.classeCSS} ${surTerre ? 'navire-terrestre' : ''}" onclick="centrerSurNavire(${navire.latitude}, ${navire.longitude})">
                        <div class="navire-header">
                            <span class="navire-nom">
                                ${emoji} ${numeroText} ${nomNavire} ${analyse.emoji}
                                ${enMouvement ? 'üîÑ' : '‚è∏Ô∏è'}
                                ${estTracke ? 'üéØ' : ''}
                                ${surTerre ? ' (TERRESTRE)' : ''}
                                ${numeroNavire && !enMouvement ? ' (num√©ro cach√© - √† l\'arr√™t)' : ''}
                            </span>
                            <span class="navire-distance ${analyse.classeDistance}">
                                ${analyse.distance}m
                            </span>
                        </div>
                        <div class="navire-details">
                            <div class="navire-detail">
                                <span>Type:</span>
                                <strong>${surTerre ? '√âmetteur terrestre' : 'Navire'}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Num√©ro:</span>
                                <strong>${numeroNavire ? `#${numeroNavire}${!enMouvement ? ' (cach√©)' : ''}` : 'Non attribu√©'}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Vitesse:</span>
                                <strong>${navire.speed || 'N/A'} kn</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Cap:</span>
                                <strong>${cap}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Longueur:</span>
                                <strong>${navire.length || 'N/A'} m</strong>
                            </div>
                            <div class="navire-detail">
                                <span>MMSI:</span>
                                <strong>${navire.mmsi || 'N/A'}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Statut:</span>
                                <strong>${enMouvement ? 'En mouvement' : '√Ä l\'arr√™t'}</strong>
                            </div>
                        </div>
                        ${estTracke ? '<div style="margin-top: 8px; padding: 4px 8px; background: #dc3545; color: white; border-radius: 4px; font-size: 11px; text-align: center;">üéØ SUIVI TEMPS R√âEL</div>' : ''}
                    </div>
                `;
            }).join('');

            listeElement.innerHTML = htmlNavires;
        }

        // Mise √† jour de la liste des navires non conformes
        function mettreAJourListeNonConformes() {
            const sectionNonConformes = document.getElementById('sectionNonConformes');
            const listeElement = document.getElementById('listeNonConformes');
            
            if (naviresNonConformes.length === 0) {
                sectionNonConformes.style.display = 'none';
                return;
            }

            sectionNonConformes.style.display = 'block';
            
            const htmlNonConformes = naviresNonConformes.map(navire => {
                const analyse = analyserNavire(navire);
                const enMouvement = estEnMouvementStabilise(navire);
                const numeroNavire = obtenirNumeroNavire(navire);
                const numeroText = numeroNavire ? `#${numeroNavire}` : '';
                
                let raisonNonConforme = [];
                if (!navire.shipName || navire.shipName.trim() === '') raisonNonConforme.push('Nom manquant');
                if (!navire.mmsi || navire.mmsi.toString().length < 6) raisonNonConforme.push('MMSI invalide');
                if (!navire.length || parseFloat(navire.length) <= 0) raisonNonConforme.push('Longueur manquante');
                if (!navire.speed && navire.speed !== 0) raisonNonConforme.push('Vitesse manquante');
                
                return `
                    <div class="navire-item navire-non-conforme" onclick="centrerSurNavire(${navire.latitude}, ${navire.longitude})">
                        <div class="navire-header">
                            <span class="navire-nom">
                                ‚ö†Ô∏è ${numeroText} ${navire.shipName || 'Inconnu'} ${enMouvement ? 'üîÑ' : '‚è∏Ô∏è'}
                            </span>
                            <span class="navire-distance distance-vigilance">
                                ${analyse.distance}m
                            </span>
                        </div>
                        <div class="navire-details">
                            <div class="navire-detail">
                                <span>Num√©ro:</span>
                                <strong>${numeroText || 'Non attribu√©'}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Vitesse:</span>
                                <strong>${navire.speed || 'N/A'} kn</strong>
                            </div>
                            <div class="navire-detail">
                                <span>MMSI:</span>
                                <strong>${navire.mmsi || 'N/A'}</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Longueur:</span>
                                <strong>${navire.length || 'N/A'} m</strong>
                            </div>
                            <div class="navire-detail">
                                <span>Type:</span>
                                <strong>${navire.shipType || 'N/A'}</strong>
                            </div>
                        </div>
                        <div style="margin-top: 8px; padding: 4px 8px; background: #ffc107; color: #000; border-radius: 4px; font-size: 11px;">
                            Probl√®me(s): ${raisonNonConforme.join(', ')}
                        </div>
                    </div>
                `;
            }).join('');
            
            listeElement.innerHTML = htmlNonConformes;
        }

        // Centrage sur navire
        function centrerSurNavire(lat, lon) {
            console.log(`üéØ Centrage sur navire: ${lat}, ${lon}`);
            map.setView([lat, lon], 15);
        }

        // Mise √† jour des statistiques
        function mettreAJourStatistiques() {
            const naviresAfficher = filtrerNavires(navires);
            let approche = 0, vigilance = 0, alerte = 0;
            
            naviresAfficher.forEach(navire => {
                const analyse = analyserNavire(navire);
                switch(analyse.statut) {
                    case 'approche': approche++; break;
                    case 'vigilance': vigilance++; break;
                    case 'alerte': alerte++; break;
                }
            });

            document.getElementById('totalNavires').textContent = naviresAfficher.length;
            document.getElementById('naviresApproche').textContent = approche;
            document.getElementById('naviresVigilance').textContent = vigilance;
            document.getElementById('naviresAlerte').textContent = alerte;
            document.getElementById('naviresTrackes').textContent = naviresTrackes.size;
            document.getElementById('naviresNumerotes').textContent = naviresNumerotes.size;
            document.getElementById('derniereMaj').textContent = new Date().toLocaleTimeString('fr-FR');
        }

        // Gestion des alertes
        function gererAlertes() {
            const naviresAfficher = filtrerNavires(navires);
            
            const naviresZoneAlerte = naviresAfficher.filter(navire => {
                const analyse = analyserNavire(navire);
                return analyse.statut === 'alerte';
            });
            
            const naviresZoneVigilance = naviresAfficher.filter(navire => {
                const analyse = analyserNavire(navire);
                return analyse.statut === 'vigilance' || analyse.statut === 'alerte';
            });
            
            const naviresAlerteMouvement = naviresZoneAlerte.filter(navire => estEnMouvementStabilise(navire));
            
            // Panneau orange : navires EN MOUVEMENT dans zone 2km - VERSION SIDEBAR
            afficherPanneauAttentionSidebar(naviresZoneVigilance);
            
            // Banni√®re rouge : navires EN MOUVEMENT dans zone 1km
            if (naviresAlerteMouvement.length > 0) {
                naviresAlerteMouvement.forEach(navire => {
                    if (!naviresEnAlerte.has(navire.mmsi)) {
                        declencherAlerteRouge(navire);
                        naviresEnAlerte.add(navire.mmsi);
                    }
                });
            }
            
            // Nettoyage des navires plus en alerte
            const mmsiActuels = new Set(naviresAlerteMouvement.map(n => n.mmsi));
            naviresEnAlerte.forEach(mmsi => {
                if (!mmsiActuels.has(mmsi)) {
                    naviresEnAlerte.delete(mmsi);
                }
            });
        }

        // R√©cup√©ration optimis√©e des navires
        async function recupererNavires(modeCible = false) {
            console.log('üîÑ R√©cup√©ration des navires depuis l\'API...', modeCible ? '(Mode cibl√©)' : '');
            
            const token = document.getElementById('token').value;
            const rayon = parseFloat(document.getElementById('rayon').value);

            if (!token) {
                throw new Error('Token API requis');
            }

            if (isNaN(rayon)) {
                throw new Error('Rayon invalide');
            }

            // Les coordonn√©es sont maintenant verrouill√©es c√¥t√© backend
            const lat = BASE_COORDS.lat;
            const lon = BASE_COORDS.lon;

            // Calcul GPS comme avant (fonctionne)
            const kmToDegrees = rayon / 111;
            const minLat = lat - kmToDegrees;
            const maxLat = lat + kmToDegrees;
            const minLon = lon - (kmToDegrees / Math.cos(lat * Math.PI / 180));
            const maxLon = lon + (kmToDegrees / Math.cos(lat * Math.PI / 180));

            const params = new URLSearchParams({
                minLat: minLat.toFixed(6),
                maxLat: maxLat.toFixed(6),
                minLon: minLon.toFixed(6),
                maxLon: maxLon.toFixed(6),
                pageSize: modeCible && naviresTrackes.size > 0 ? '20' : '100'
            });
            

            const url = `api/euris-proxy.php?${params.toString()}`;
            
            console.log('üåê URL appel√©e:', url, modeCible ? '(Requ√™te optimis√©e)' : '');
            
            const response = await fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json',
                    'Accept': 'application/json'
                }
            });
            
            console.log('üì° R√©ponse re√ßue - Status:', response.status);
            
            if (!response.ok) {
                let errorMessage = `Erreur HTTP ${response.status}: ${response.statusText}`;
                let errorDetails = null;
                
                try {
                    const errorData = await response.json();
                    errorMessage = errorData.error || errorMessage;
                    errorDetails = errorData;
                    console.error('‚ùå D√©tails de l\'erreur:', errorData);
                } catch (e) {
                    console.error('‚ùå Impossible de parser l\'erreur JSON');
                    const errorText = await response.text();
                    errorDetails = errorText;
                    console.error('‚ùå R√©ponse d\'erreur (texte):', errorText);
                }
                
                const error = new Error(errorMessage);
                error.details = errorDetails;
                error.status = response.status;
                throw error;
            }

            const data = await response.json();
            console.log('üìä Donn√©es re√ßues:', data);
            
            if (!data) {
                throw new Error('R√©ponse vide de l\'API');
            }

            let naviresData = [];
            if (data.tracks && Array.isArray(data.tracks)) {
                naviresData = data.tracks;
            } else if (Array.isArray(data)) {
                naviresData = data;
            } else if (data.data && Array.isArray(data.data)) {
                naviresData = data.data;
            } else {
                console.warn('‚ö†Ô∏è Aucun tableau de navires trouv√© dans la r√©ponse');
                naviresData = [];
            }

            const naviresFiltr√©s = naviresData.filter(navire => {
                if (!navire || typeof navire.latitude !== 'number' || typeof navire.longitude !== 'number') {
                    console.warn('‚ö†Ô∏è Navire sans coordonn√©es valides:', navire);
                    return false;
                }
                
                const distance = calculerDistance(lat, lon, navire.latitude, navire.longitude);
                return distance <= (rayon * 1000);
            });

            console.log(`‚úÖ ${naviresFiltr√©s.length} navires dans la zone de ${rayon}km apr√®s filtrage`);
            return naviresFiltr√©s;
        }

        // Mise √† jour compl√®te des donn√©es
        async function mettreAJourDonnees() {
            try {
                console.log('üîÑ D√©but de la mise √† jour des donn√©es');
                afficherStatut('connecting', 'Connexion √† l\'API ...');
                
                // Utiliser le mode cibl√© si on est en mode alerte
                const modeCible = modeActualisation === 'alerte';
                const tousLesNavires = await recupererNavires(modeCible);
                
                // Tous les navires sont affich√©s (comme avant)
                navires = tousLesNavires;

                // Num√©rotation au premier scan ou attribution de nouveaux num√©ros
                if (naviresNumerotes.size === 0) {
                    console.log('üéØ Premier scan : num√©rotation initiale');
                    numerotationInitiale(navires);
                } else {
                    console.log('üîÑ Scan suivant : attribution nouveaux + nettoyage');
                    navires.forEach(navire => {
                        if (estEnMouvementStabilise(navire)) {
                            attribuerNumero(navire);
                        }
                    });
                    nettoyageRGPD(navires);
                    nettoyageHistoriqueVitesses(navires);
                }
                
                // Optionnel : identifier les navires avec des donn√©es manquantes qui peuvent bouger
                naviresNonConformes = tousLesNavires.filter(navire => {
                    return estNavireNonConformeEnMouvement(navire);
                });
                
                console.log(`üìä ${navires.length} navires conformes, ${naviresNonConformes.length} non conformes en mouvement`);
                
                mettreAJourBase();
                map.setView([coordsActuelles.lat, coordsActuelles.lon], map.getZoom());
                
                gererTrackingZoneRouge();
                
                mettreAJourMarqueurs();
                mettreAJourListeNavires();
                mettreAJourListeNonConformes();
                mettreAJourStatistiques();
                gererAlertes();

                // Gestion du compteur journalier
                await gererComptageZoneRouge(navires);
                // afficherPanneauCompteur() est d√©j√† appel√© dans gererComptageZoneRouge

                const naviresAfficher = filtrerNavires(navires);
                let statusMessage = `${naviresAfficher.length} navires surveill√©s`;
                if (naviresTrackes.size > 0) {
                    statusMessage += ` (${naviresTrackes.size} track√©s)`;
                }
                if (naviresNonConformes.length > 0) {
                    statusMessage += ` - ${naviresNonConformes.length} non conformes`;
                }
                if (naviresNumerotes.size > 0) {
                    statusMessage += ` - ${naviresNumerotes.size} num√©rot√©s`;
                }
                
                if (naviresAfficher.length > 0 || naviresNonConformes.length > 0) {
                    afficherStatut('connected', statusMessage);
                } else {
                    afficherStatut('connected', 'Aucun navire dans la zone');
                    afficherMessage('info', 'Zone claire', 'Aucun navire d√©tect√© dans la zone de surveillance.');
                }
                
                console.log('‚úÖ Mise √† jour termin√©e avec succ√®s');
                
            } catch (error) {
                console.error('‚ùå Erreur lors de la mise √† jour:', error);
                
                afficherStatut('error', 'Erreur de connexion');
                
                let messageErreur = error.message;
                let details = null;
                
                if (error.details) {
                    details = error.details;
                }
                
                if (error.status) {
                    switch (error.status) {
                        case 401:
                            messageErreur = 'Token d\'authentification invalide ou expir√©';
                            break;
                        case 403:
                            messageErreur = 'Acc√®s interdit - permissions insuffisantes';
                            break;
                        case 404:
                            messageErreur = 'Service non trouv√©';
                            break;
                        case 429:
                            messageErreur = 'Trop de requ√™tes - attendez avant de r√©essayer';
                            break;
                        case 500:
                        case 502:
                        case 503:
                        case 504:
                            messageErreur = 'Service temporairement indisponible';
                            break;
                    }
                }
                
                afficherMessage('error', 'Erreur de r√©cup√©ration', messageErreur, details);
            }
        }

        // Gestion du compteur de rafra√Æchissement
        function demarrerCompteur() {
            const compteurElement = document.getElementById('compteurRefresh');
            const tempsElement = document.getElementById('tempsRestant');
            
            compteurElement.style.display = 'block';
            
            intervalleCompteur = setInterval(() => {
                tempsElement.textContent = tempsRestant;
                tempsRestant--;
                
                if (tempsRestant < 0) {
                    const delaiActuel = modeActualisation === 'alerte' ? REFRESH_ALERTE : REFRESH_NORMAL;
                    tempsRestant = delaiActuel;
                    mettreAJourDonnees();
                }
            }, 1000);
        }

        // Arr√™t de la surveillance
        function arreterSurveillance() {
            console.log('‚èπÔ∏è Arr√™t de la surveillance');
            
            surveillanceActive = false;
            
            if (intervalleRefresh) {
                clearInterval(intervalleRefresh);
            }
            if (intervalleCompteur) {
                clearInterval(intervalleCompteur);
            }
            
            document.getElementById('compteurRefresh').style.display = 'none';
            document.getElementById('panneauAttentionSidebar').style.display = 'none';
            
            const btn = document.getElementById('btnSurveillance');
            btn.textContent = 'üîç D√©marrer la surveillance';
            btn.disabled = false;
            
            document.getElementById('statusIndicator').style.display = 'none';
            document.getElementById('sectionNonConformes').style.display = 'none';
            
            naviresEnAlerte.clear();
            naviresTrackes.clear();
            modeActualisation = 'normal';
            
            const banniere = document.getElementById('banniereAlerte');
            if (banniere) banniere.remove();
            
            document.getElementById('listeNavires').innerHTML = '<div class="loading">Cliquez sur "D√©marrer la surveillance" pour commencer...</div>';
            
            console.log(`üìã Num√©rotation persistante: ${naviresNumerotes.size} navires gard√©s en m√©moire`);
        }

        // D√©marrage de la surveillance
        async function demarrerSurveillance() {
            console.log('üöÄ D√©marrage de la surveillance automatique');
            
            const btn = document.getElementById('btnSurveillance');
            
            if (surveillanceActive) {
                arreterSurveillance();
                return;
            }
            
            const token = document.getElementById('token').value.trim();
            if (!token) {
                alert('Veuillez saisir votre token d\'acc√®s');
                return;
            }
            
            const rayon = parseFloat(document.getElementById('rayon').value);
            
            if (isNaN(rayon)) {
                alert('Veuillez v√©rifier le rayon');
                return;
            }
            
            if (rayon < 1) {
                alert('Le rayon minimum est de 1 km');
                return;
            }
            
            try {
                btn.textContent = '‚èπÔ∏è Arr√™ter la surveillance';
                btn.disabled = true;
                
                await mettreAJourDonnees(true); // Premi√®re demande avec num√©rotation initiale
                
                surveillanceActive = true;
                btn.disabled = false;
                
                tempsRestant = modeActualisation === 'alerte' ? REFRESH_ALERTE : REFRESH_NORMAL;
                demarrerCompteur();
                
                console.log(`‚úÖ Surveillance d√©marr√©e - Mode: ${modeActualisation} - D√©lai: ${tempsRestant + 1}s`);
                
            } catch (error) {
                console.error('‚ùå Erreur lors du d√©marrage:', error);
                
                btn.textContent = 'üîç D√©marrer la surveillance';
                btn.disabled = false;
                
                let messageErreur = error.message;
                if (error.status === 401) {
                    messageErreur = 'Token invalide. V√©rifiez votre token d\'acc√®s.';
                } else if (error.status === 403) {
                    messageErreur = 'Acc√®s refus√©. V√©rifiez les permissions de votre token.';
                }
                
                alert('Erreur lors du d√©marrage de la surveillance:\n' + messageErreur);
            }
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('üåü Initialisation de l\'application TrackShip - Version avec num√©rotation persistante + MySQL');

            // Initialisation du syst√®me de num√©rotation RGPD
            await initialiserNumerotation();

            initMap();
            
            window.addEventListener('beforeunload', function() {
                if (surveillanceActive) {
                    arreterSurveillance();
                }
                // Sauvegarde finale du compteur uniquement (pas des navires - RGPD)
                sauvegarderCompteur();
            });
            
            console.log('‚úÖ Application initialis√©e et pr√™te sur trackship.bakabi.fr');
            console.log('üéØ Nouvelles fonctionnalit√©s: Num√©rotation RGPD conforme, Coordonn√©es verrouill√©es, Panneau sidebar');
            console.log(`üìã Syst√®me conforme RGPD: oubli automatique des navires sortis de zone`);
        });
    </script>
</body>
</html>